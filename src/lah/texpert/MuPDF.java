/*
 * This file is derived from MuPDF Android app's source code by packaging a minimal amount of code for the purpose of TeXpert.
 * Major changes are:
 *  - The name of class MuPDFCore is simplified to MuPDF.
 *  - Remove methods and fields related to text selection, editing, links, script, etc.
 * 
 * @author L.A.H.
 * @modified-date 28 May 2013
 */
package lah.texpert;


//class MuPDFPageView extends ViewGroup {
//
//	private static final int BACKGROUND_COLOR = 0xFFFFFFFF;
//	private static final int PROGRESS_DIALOG_DELAY = 200;
//	private ProgressBar mBusyIndicator;
//	private final Context mContext;
//	private final MuPDF mCore;
//	private AsyncTask<Void, Void, Bitmap> mDrawEntire;
//	private AsyncTask<PatchInfo, Void, PatchInfo> mDrawPatch;
//
//	private ImageView mEntire; // Image rendered at minimum zoom
//	private BitmapHolder mEntireBmh;
//	private final Handler mHandler = new Handler();
//	protected int mPageNumber;
//	private Point mParentSize;
//	private ImageView mPatch;
//	private Rect mPatchArea;
//	private BitmapHolder mPatchBmh;
//	private Point mPatchViewSize; // View size on the basis of which the patch was created
//	protected Point mSize; // Size of page at minimum zoom
//	protected float mSourceScale;
//
//	public MuPDFPageView(Context c, MuPDF core, Point parentSize) {
//		super(c);
//		mContext = c;
//		mParentSize = parentSize;
//		setBackgroundColor(BACKGROUND_COLOR);
//		mEntireBmh = new BitmapHolder();
//		mPatchBmh = new BitmapHolder();
//		mCore = core;
//	}
//
//	public void addHq(boolean update) {
//		Rect viewArea = new Rect(getLeft(), getTop(), getRight(), getBottom());
//		// If the viewArea's size matches the unzoomed size, there is no need for an hq patch
//		if (viewArea.width() != mSize.x || viewArea.height() != mSize.y) {
//			Point patchViewSize = new Point(viewArea.width(), viewArea.height());
//			Rect patchArea = new Rect(0, 0, mParentSize.x, mParentSize.y);
//
//			// Intersect and test that there is an intersection
//			if (!patchArea.intersect(viewArea))
//				return;
//
//			// Offset patch area to be relative to the view top left
//			patchArea.offset(-viewArea.left, -viewArea.top);
//
//			boolean area_unchanged = patchArea.equals(mPatchArea) && patchViewSize.equals(mPatchViewSize);
//
//			// If being asked for the same area as last time and not because of an update then nothing to do
//			if (area_unchanged && !update)
//				return;
//
//			boolean completeRedraw = !(area_unchanged && update);
//
//			// Stop the drawing of previous patch if still going
//			if (mDrawPatch != null) {
//				mDrawPatch.cancel(true);
//				mDrawPatch = null;
//			}
//
//			if (completeRedraw) {
//				// The bitmap holder mPatchBm may still be rendered to by a
//				// previously invoked task, and possibly for a different
//				// area, so we cannot risk the bitmap generated by this task
//				// being passed to it
//				mPatchBmh.drop();
//				mPatchBmh = new BitmapHolder();
//			}
//
//			// Create and add the image view if not already done
//			if (mPatch == null) {
//				mPatch = new OpaqueImageView(mContext);
//				mPatch.setScaleType(ImageView.ScaleType.FIT_CENTER);
//				addView(mPatch);
//			}
//
//			mDrawPatch = new AsyncTask<PatchInfo, Void, PatchInfo>() {
//				protected PatchInfo doInBackground(PatchInfo... v) {
//					if (v[0].completeRedraw) {
//						v[0].bm = drawPage(v[0].patchViewSize.x, v[0].patchViewSize.y, v[0].patchArea.left,
//								v[0].patchArea.top, v[0].patchArea.width(), v[0].patchArea.height());
//					} else {
//						v[0].bm = updatePage(v[0].bmh, v[0].patchViewSize.x, v[0].patchViewSize.y, v[0].patchArea.left,
//								v[0].patchArea.top, v[0].patchArea.width(), v[0].patchArea.height());
//					}
//
//					return v[0];
//				}
//
//				protected void onPostExecute(PatchInfo v) {
//					if (mPatchBmh == v.bmh) {
//						mPatchViewSize = v.patchViewSize;
//						mPatchArea = v.patchArea;
//						if (v.bm != null) {
//							mPatch.setImageBitmap(v.bm);
//							v.bmh.setBm(v.bm);
//							v.bm = null;
//						}
//						// requestLayout();
//						// Calling requestLayout here doesn't lead to a later call to layout. No idea
//						// why, but apparently others have run into the problem.
//						mPatch.layout(mPatchArea.left, mPatchArea.top, mPatchArea.right, mPatchArea.bottom);
//						invalidate();
//					}
//				}
//			};
//
//			mDrawPatch.execute(new PatchInfo(patchViewSize, patchArea, mPatchBmh, completeRedraw));
//		}
//	}
//
//	public void blank(int page) {
//		reinit();
//		mPageNumber = page;
//
//		if (mBusyIndicator == null) {
//			mBusyIndicator = new ProgressBar(mContext);
//			mBusyIndicator.setIndeterminate(true);
//			addView(mBusyIndicator);
//		}
//	}
//
//	protected Bitmap drawPage(int sizeX, int sizeY, int patchX, int patchY, int patchWidth, int patchHeight) {
//		return mCore.drawPage(mPageNumber, sizeX, sizeY, patchX, patchY, patchWidth, patchHeight);
//	}
//
//	public int getPage() {
//		return mPageNumber;
//	}
//
//	@Override
//	public boolean isOpaque() {
//		return true;
//	}
//
//	@Override
//	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
//		int w = right - left;
//		int h = bottom - top;
//
//		if (mEntire != null) {
//			mEntire.layout(0, 0, w, h);
//		}
//
//		if (mPatchViewSize != null) {
//			if (mPatchViewSize.x != w || mPatchViewSize.y != h) {
//				// Zoomed since patch was created
//				mPatchViewSize = null;
//				mPatchArea = null;
//				if (mPatch != null) {
//					mPatch.setImageBitmap(null);
//					mPatchBmh.setBm(null);
//				}
//			} else {
//				mPatch.layout(mPatchArea.left, mPatchArea.top, mPatchArea.right, mPatchArea.bottom);
//			}
//		}
//
//		if (mBusyIndicator != null) {
//			int bw = mBusyIndicator.getMeasuredWidth();
//			int bh = mBusyIndicator.getMeasuredHeight();
//
//			mBusyIndicator.layout((w - bw) / 2, (h - bh) / 2, (w + bw) / 2, (h + bh) / 2);
//		}
//	}
//
//	@Override
//	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
//		int x, y;
//		switch (View.MeasureSpec.getMode(widthMeasureSpec)) {
//		case View.MeasureSpec.UNSPECIFIED:
//			x = mSize.x;
//			break;
//		default:
//			x = View.MeasureSpec.getSize(widthMeasureSpec);
//		}
//		switch (View.MeasureSpec.getMode(heightMeasureSpec)) {
//		case View.MeasureSpec.UNSPECIFIED:
//			y = mSize.y;
//			break;
//		default:
//			y = View.MeasureSpec.getSize(heightMeasureSpec);
//		}
//
//		setMeasuredDimension(x, y);
//
//		if (mBusyIndicator != null) {
//			int limit = Math.min(mParentSize.x, mParentSize.y) / 2;
//			mBusyIndicator.measure(View.MeasureSpec.AT_MOST | limit, View.MeasureSpec.AT_MOST | limit);
//		}
//	}
//
//	private void reinit() {
//		// Cancel pending render task
//		if (mDrawEntire != null) {
//			mDrawEntire.cancel(true);
//			mDrawEntire = null;
//		}
//
//		if (mDrawPatch != null) {
//			mDrawPatch.cancel(true);
//			mDrawPatch = null;
//		}
//
//		// mIsBlank = true;
//		mPageNumber = 0;
//
//		if (mSize == null)
//			mSize = mParentSize;
//
//		if (mEntire != null) {
//			mEntire.setImageBitmap(null);
//			mEntireBmh.setBm(null);
//		}
//
//		if (mPatch != null) {
//			mPatch.setImageBitmap(null);
//			mPatchBmh.setBm(null);
//		}
//
//		mPatchViewSize = null;
//		mPatchArea = null;
//	}
//
//	public void releaseResources() {
//		reinit();
//
//		if (mBusyIndicator != null) {
//			removeView(mBusyIndicator);
//			mBusyIndicator = null;
//		}
//	}
//
//	public void removeHq() {
//		// Stop the drawing of the patch if still going
//		if (mDrawPatch != null) {
//			mDrawPatch.cancel(true);
//			mDrawPatch = null;
//		}
//
//		// And get rid of it
//		mPatchViewSize = null;
//		mPatchArea = null;
//		if (mPatch != null) {
//			mPatch.setImageBitmap(null);
//			mPatchBmh.setBm(null);
//		}
//	}
//
//	public void setPage(int page, PointF size) {
//		// Cancel pending render task
//		if (mDrawEntire != null) {
//			mDrawEntire.cancel(true);
//			mDrawEntire = null;
//		}
//
//		// mIsBlank = false;
//
//		mPageNumber = page;
//		if (mEntire == null) {
//			mEntire = new OpaqueImageView(mContext);
//			mEntire.setScaleType(ImageView.ScaleType.FIT_CENTER);
//			addView(mEntire);
//		}
//
//		// Calculate scaled size that fits within the screen limits
//		// This is the size at minimum zoom
//		mSourceScale = Math.min(mParentSize.x / size.x, mParentSize.y / size.y);
//		Point newSize = new Point((int) (size.x * mSourceScale), (int) (size.y * mSourceScale));
//		mSize = newSize;
//
//		mEntire.setImageBitmap(null);
//		mEntireBmh.setBm(null);
//
//		// Render the page in the background
//		mDrawEntire = new AsyncTask<Void, Void, Bitmap>() {
//			protected Bitmap doInBackground(Void... v) {
//				return drawPage(mSize.x, mSize.y, 0, 0, mSize.x, mSize.y);
//			}
//
//			protected void onPostExecute(Bitmap bm) {
//				removeView(mBusyIndicator);
//				mBusyIndicator = null;
//				mEntire.setImageBitmap(bm);
//				mEntireBmh.setBm(bm);
//				invalidate();
//			}
//
//			protected void onPreExecute() {
//				mEntire.setImageBitmap(null);
//				mEntireBmh.setBm(null);
//
//				if (mBusyIndicator == null) {
//					mBusyIndicator = new ProgressBar(mContext);
//					mBusyIndicator.setIndeterminate(true);
//					addView(mBusyIndicator);
//					mBusyIndicator.setVisibility(INVISIBLE);
//					mHandler.postDelayed(new Runnable() {
//						public void run() {
//							if (mBusyIndicator != null)
//								mBusyIndicator.setVisibility(VISIBLE);
//						}
//					}, PROGRESS_DIALOG_DELAY);
//				}
//			}
//		};
//
//		mDrawEntire.execute();
//		requestLayout();
//	}
//
//	public void setScale(float scale) {
//		// This type of view scales automatically to fit the size determined by the parent view groups during layout
//	}
//
//	public void update() {
//		// Cancel pending render task
//		if (mDrawEntire != null) {
//			mDrawEntire.cancel(true);
//			mDrawEntire = null;
//		}
//
//		if (mDrawPatch != null) {
//			mDrawPatch.cancel(true);
//			mDrawPatch = null;
//		}
//
//		// Render the page in the background
//		mDrawEntire = new AsyncTask<Void, Void, Bitmap>() {
//			protected Bitmap doInBackground(Void... v) {
//				// Pass the current bitmap as a basis for the update, but use a bitmap
//				// holder so that the held bitmap will be nulled and not hold on to
//				// memory, should this view become redundant.
//				return updatePage(mEntireBmh, mSize.x, mSize.y, 0, 0, mSize.x, mSize.y);
//			}
//
//			protected void onPostExecute(Bitmap bm) {
//				if (bm != null) {
//					mEntire.setImageBitmap(bm);
//					mEntireBmh.setBm(bm);
//				}
//				invalidate();
//			}
//		};
//
//		mDrawEntire.execute();
//
//		addHq(true);
//	}
//
//	protected Bitmap updatePage(BitmapHolder h, int sizeX, int sizeY, int patchX, int patchY, int patchWidth,
//			int patchHeight) {
//		return mCore.updatePage(h, mPageNumber, sizeX, sizeY, patchX, patchY, patchWidth, patchHeight);
//	}
//}
//
//// Make our ImageViews opaque to optimize redraw
//class OpaqueImageView extends ImageView {
//
//	public OpaqueImageView(Context context) {
//		super(context);
//	}
//
//	@Override
//	public boolean isOpaque() {
//		return true;
//	}
//}
//
//class PatchInfo {
//	public Bitmap bm;
//	public BitmapHolder bmh;
//	public boolean completeRedraw;
//	public Rect patchArea;
//	public Point patchViewSize;
//
//	public PatchInfo(Point aPatchViewSize, Rect aPatchArea, BitmapHolder aBmh, boolean aCompleteRedraw) {
//		bmh = aBmh;
//		bm = null;
//		patchViewSize = aPatchViewSize;
//		patchArea = aPatchArea;
//		completeRedraw = aCompleteRedraw;
//	}
//}
